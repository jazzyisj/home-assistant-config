###############################################################################
## TTS Play
###############################################################################
tts_play:
  alias: "TTS Play"
  description: "Play TTS announcement message."
  mode: queued
  max: 20
  max_exceeded: error
  trace:
    stored_traces: 20
  fields:
    message:
      description: "TTS Message to play."
      example: "This is a test message."
    alert:
      description: Message is an alert. (overrides tts, media player, and volume)
      example: "false"
    tts_service:
      description: "Override service to use for TTS."
      example: "tts.cloud_say"
    gender:
      description: "Override gender to use for TTS (Nabu Casa only)."
      example: "male"
    language:
      description: "Override languagle to use for TTS (Nabu Casa only)."
      example: "en-CA"
    media_player:
      description: "Override default media player."
      example: "media_player.broadcast_speakers"
    min_volume:
      description: "Percent - override volume level"
      example: "50"
    quiet_play:
      description: Play announcement during quiet time.
      example: "true"
    night_play:
      description: Play announcement during night mode.
      example: "true"
    ignore_away:
      description: Play announcement when nobody home.
      example: "true"
    save_message:
      description: Save message to play when home or after alarm.
      example: "true"
  variables:
    min_volume: "{{ min_volume|default(-1)|float }}"
    quiet_play: "{{ quiet_play|default(false) }}"
    night_play: "{{ night_play|default(false) }}"
    ignore_away: "{{ ignore_away|default(false) }}"
    save_msg: "{{ save_message|default(false) }}"
    alert: "{{ alert|default(false) }}"
  sequence:
    - service: notify.tts_message_history
      data:
        message: "{{ (now() ~ ' ' ~ message)[0:250]|replace('\n',' ') }}"

    - service: browser_mod.notification
      data:
        duration: 30000
        message: "{{ message }}"

    - or:
        - condition: state
          entity_id: input_boolean.tts_enabled
          state: "on"

        - condition: template
          value_template: "{{ alert }}"

    - variables:
        media_player: >
          {% if is_state('binary_sensor.wan','off') %}
            media_player.kiosk_internal
          {% else %}
            {% if media_player is defined %} {{ media_player }}
            {% else %} {{ iif(alert,states('sensor.tts_alert_media_player'),states('sensor.tts_media_player')) }}
            {% endif %}
          {% endif %}
        tts_player: > #MASS not using snapshot not working
          {% if is_state('binary_sensor.mass_media','on') %}
            {{ iif(has_value(media_player ~ '_2'),media_player ~ '_2',media_player) }}
          {% else %}
            {{ media_player }}
          {% endif %}
        media_players: >
          {{ expand(state_attr('sensor.' ~ media_player.split('.')[1],'entity_id')
                if is_state_attr(media_player,'type','group') else [media_player])
              |map(attribute='entity_id')|list }}
        tts_service: > # force local tts service if wan disconnected
          {% if is_state('binary_sensor.wan','off') %} {% set tts = 'tts.piper' %}
          {% else %}
            {% if is_state('input_select.tts_service','Piper TTS') %} {% set tts = 'tts.piper' %}
            {% elif is_state('input_select.tts_service','Google Cloud') %} {% set tts = 'tts.google_cloud_say' %}
            {% elif is_state('input_select.tts_service','Broadcast') %} {% set tts = 'broadcast' %}
            {% else %} {% set tts = 'tts.cloud_say' %}
            {% endif %}
          {% endif %}
          {{ tts_service|default(tts) }}
        volume: >
          {% if alert %}
            {% set volume = states('input_number.tts_volume_alert')|int %}
          {% elif is_state('input_boolean.tts_override','on') %}
            {% set volume = states('input_number.tts_volume_manual')|int %}
          {% elif is_state('input_select.occupancy_mode','Night') %}
            {% set volume = states('input_number.tts_volume_night')|int %}
          {% elif is_state('binary_sensor.quiet_time','on') %}
            {% set volume = states('input_number.tts_volume_quiet')|int %}
          {% else %}
            {% set volume = states('input_number.tts_volume')|int %}
          {% endif %}
          {{ min_volume/100 if min_volume > -1 and (min_volume > volume) else volume/100 }}
        mute_tts: >
          {{ false if alert
              else is_state('switch.system_mute','on')
              or is_state('input_boolean.alarm_triggered','on')
              or (is_state('binary_sensor.quiet_time','on') and not quiet_play)
              or (is_state('binary_sensor.scene_active','on') and not night_play)
              or (is_state('input_select.occupancy_mode','Night') and not night_play)
              or (is_state('binary_sensor.someone_home','off') and not ignore_away)
              or media_players|count == 0
              or volume == 0 }}

    - choose:
        - conditions: "{{ mute_tts }}"
          sequence:
            # prevents mass resume / volume reset
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.tts_muted

            - if: >
                {{ is_state('input_boolean.jason_phone_tts_enabled','on')
                    and is_state('binary_sensor.jason_home','on')
                    and (quiet_play or night_play) }}
              then:
                - service: notify.jason
                  data:
                    message: TTS
                    data:
                      tts_text: "{{ message }}"
                      channel: alarm_stream

            # save message if message is flagged for save
            - if:
                - "{{ save_msg }}"
              then:
                - service: script.turn_on
                  target:
                    entity_id: script.tts_save_message
                  data:
                    variables:
                      message: "{{ message }}"

        - conditions: "{{ tts_service == 'broadcast' }}"
          sequence:
            #TODO how is announcement volume determined?
            # don't reset volumes etc.
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.tts_muted

            - service: notify.google_assistant_sdk
              data:
                message: "{{ message }}"
                target: >
                  {{ states.media_player
                    |selectattr('entity_id','eq',media_player)
                    |map(attribute='name')|join }}

            - delay: 10 # keep script running for a few seconds

      default:
        - variables:
            mass_players: >
              {{ states.media_player|selectattr('attributes.group_members','defined')
                    |selectattr('state','in',['playing','paused','buffering','on'])|map(attribute='entity_id')|list }}

        - service: input_boolean.turn_off
          target:
            entity_id: input_boolean.tts_muted

        # turn boolean on to start announcement queue
        - service: input_boolean.turn_on
          target:
            entity_id: input_boolean.tts

        # store tts players for tts queue finished
        - service: input_text.set_value
          target:
            entity_id: input_text.tts_active_players
          data:
            value: "{{ media_players|join(',') }}"

        #MASS media playing on tts player, turn on resume boolean
        - if:
            - condition: state
              entity_id: binary_sensor.mass_media
              state: "on"

            - condition: state
              entity_id: input_boolean.resume_mass
              state: "off"
          then:
            - variables:
                mass_queues: >
                  {% set mass_queues = namespace(entity_id=[]) %}
                  {% if mass_players|count > 0 %}
                    {% for player in expand(mass_players) %}
                      {% if player.attributes.mass_player_id == player.attributes.active_queue %}
                      {% set hass_player = player.entity_id|replace('_2','') %}
                        {% if is_state_attr(hass_player,'type','group') %}
                          {% set tts_group = state_attr('sensor.' ~ hass_player.split('.')[1],'entity_id') %}
                          {% for item in tts_group %}
                            {% if item == states('sensor.tts_media_player')
                                or item in state_attr('sensor.tts_media_player','entity_id') %}
                              {% set mass_queues.entity_id = mass_queues.entity_id + [player.entity_id] %}
                            {% endif %}
                          {% endfor %}
                        {% else %}
                          {% if hass_player == states('sensor.tts_media_player')
                              or hass_player in state_attr('sensor.tts_media_player','entity_id') %}
                            {% set mass_queues.entity_id = mass_queues.entity_id + [player.entity_id] %}
                          {% endif %}
                        {% endif %}
                      {% endif %}
                    {% endfor %}
                  {% endif %}
                  {{ mass_queues.entity_id|unique|list }}

            - condition: template
              value_template: "{{ mass_queues|count > 0 }}"

            # store active mass players for tts queue finished
            - service: input_text.set_value
              target:
                entity_id: input_text.tts_restore_mass
              data:
                value: "{{ mass_queues|join(',') }}"

            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.resume_mass

            # create queue snapshot for mass players
            # - repeat:
            #     for_each: "{{ mass_queues }}"
            #     sequence:
            #       - service: mass.queue_command
            #         data:
            #           player_id: "{{ mass_queues[repeat.index-1] }}"
            #           command: snapshot_create #MASS not working

        - service: script.media_player_set_volumes
          data:
            source: tts_all # lower active media player volumes for tts
          continue_on_error: true

        - service: script.media_players_pause
          data:
            entity_id: "{{ media_player }}"
          continue_on_error: true

        - service: script.turn_media_player_on
          data:
            entity_id: "{{ media_player }}"
          continue_on_error: true

        # filter out muted media players so we don't unmute (player must be on for is_volume_muted)
        - variables:
            active_players: >
              {% set muted_players = expand(media_players)|selectattr('attributes.is_volume_muted','defined')
                |selectattr('attributes.is_volume_muted','eq',true)|map(attribute='entity_id')|list %}
              {{ expand(media_players)|rejectattr('entity_id','in',muted_players)|map(attribute='entity_id')|list }}

        # set volume before player override volumes
        #ISSUE no way to avoid google home volume pops here
        - service: media_player.volume_set
          target:
            entity_id: "{{ active_players }}"
          data:
            volume_level: "{{ volume }}"
          continue_on_error: true

        #ISSUE ensure kiosk tablet media player volume is set, no mute - must be before muted players filtered out
        - if: "{{ 'media_player.kiosk_internal' in active_players }}"
          then:
            - service: media_player.volume_set
              target:
                entity_id: media_player.fire_tablet
              data:
                volume_level: 0.8
              continue_on_error: true

        # volume exceptions - skip exceptions if alert (use alert volume)
        - if: "{{ not alert }}"
          then:
            # increase bathroom speaker volume if shower script is on
            - if: >
                {{ 'media_player.bathroom_speaker' in active_players
                      and is_state('switch.shower_scene','on') }}
              then:
                - service: media_player.volume_set
                  target:
                    entity_id: media_player.bathroom_speaker
                  data:
                    volume_level: "{{ iif(is_state('binary_sensor.quiet_time','off'),0.9,0.6) }}"

        - delay: 1 # allow volumes to set

        # play tts message
        - choose:
            - conditions: "{{ tts_service == 'tts.cloud_say' }}"
              sequence:
                - service: tts.cloud_say
                  target:
                    entity_id: "{{ media_player }}"
                  data:
                    message: "{{ message }}"
                    language: >
                      {% if alert %} en-US
                      {% else %}
                        {% set voice = states('input_select.tts_cloud_voice') %}
                        {% if 'en-AU' in voice %} {% set lang = 'en-AU' %}
                        {% elif 'en-CA' in voice %} {% set lang = 'en-CA' %}
                        {% elif 'en-IN' in voice %} {% set lang = 'en-IN' %}
                        {% elif 'en-IE' in voice %} {% set lang = 'en-IE' %}
                        {% elif 'en-GB' in voice %} {% set lang = 'en-GB' %}
                        {% elif 'en-US' in voice %} {% set lang = 'en-US' %}
                        {% else %} {% set lang = 'en-CA' %}
                        {% endif %}
                        {{ language|default(lang) }}
                      {% endif %}
                    options:
                      gender: "{{ gender|default('female' if 'Female' in states('input_select.tts_cloud_voice') else 'male') }}"
                  continue_on_error: true #ISSUE #MASS script does not continue if mass fails

            - conditions: "{{ tts_service == 'tts.piper' }}"
              sequence:
                - service: tts.speak
                  data:
                    cache: true
                    media_player_entity_id: "{{ media_player }}"
                    message: "{{ message }}"
                  target:
                    entity_id: tts.piper
          default:
            - service: "{{ tts_service }}"
              target:
                entity_id: "{{ media_player }}"
              data:
                message: "{{ message }}"
              continue_on_error: true #ISSUE #MASS script does not continue if mass fails

        # wait for media player to start playing
        - wait_template: "{{ is_state(media_player,'playing') }}"
          timeout: 30

        # tts failed script if announcement is not playing after wait timeout
        - if: "{{ not is_state(media_player,'playing') }}"
          then:
            - service: script.turn_on
              target:
                entity_id: script.tts_failed
              data:
                variables:
                  tts_service: "{{ tts_service }}"
                  media_player: "{{ media_player }}"
                  tts_player: "{{ tts_player }}"
                  message: "{{ message }}"
              continue_on_error: true
          else:
            # wait for media player to stop playing
            - wait_template: "{{ not is_state(media_player,'playing') }}"
              timeout: 120 # longest possible tts message
